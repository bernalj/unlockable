<!DOCTYPE html>
<html lang="en">
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta charset="UTF-8">
  <title>Unlockable</title>
  <style>
    :root {
      /* Default firework potency (1 = 100% potency) */
      --firework-potency: 1;
    }
    /* Reset and basic styling */
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    body {
      font-family: Arial, sans-serif;
      background: #222;
      color: #fff;
      overflow: hidden;
    }
    /* Main Menu Overlay */
    #mainMenu {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.95);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 30;
    }
    /* Background animation elements */
    #menuBackground {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 29;
    }
    #menuBackgroundGrid {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      display: grid;
      grid-template-columns: repeat(3, 80px);
      grid-template-rows: repeat(3, 80px);
      gap: 30px;
      opacity: 0.7;
    }
    #menuBackgroundGrid .circle {
      background: linear-gradient(#666, #333 40%, #333 3%, #222);
      box-shadow: inset 0 0 8px rgba(255,255,255,0.4), inset 0 0 5px rgba(0,0,0,0.3);
    }
    #menuBackgroundGrid .circle.active {
      background: linear-gradient(#F57F17, #FDD835 3%, #FDD835 40%, #FFF176);
      transform: scale(1.1);
    }
    .main-menu-content {
      text-align: center;
      z-index: 31;
      background: rgba(0, 0, 0, 0.8);
      padding: 40px;
      border-radius: 20px;
      box-shadow: 0 0 20px rgba(255, 215, 0, 0.2);
    }
    .main-menu-logo {
      font-size: 48px;
      font-weight: bold;
      margin-bottom: 40px;
      color: #FFD700;
      text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
      letter-spacing: 2px;
    }
    .main-menu-content button {
      display: block;
      width: 200px;
      margin: 15px auto;
      padding: 12px 20px;
      font-size: 20px;
      border: none;
      background: linear-gradient(45deg, rgba(255, 215, 0, 0.2), rgba(255, 165, 0, 0.2));
      color: #FFD700;
      cursor: pointer;
      border-radius: 10px;
      transition: transform 0.2s, box-shadow 0.2s, background 0.2s;
      backdrop-filter: blur(5px);
      border: 1px solid rgba(255, 215, 0, 0.3);
    }
    .main-menu-content button:hover {
      transform: scale(1.05);
      box-shadow: 0 0 15px rgba(255, 215, 0, 0.3);
      background: linear-gradient(45deg, rgba(255, 215, 0, 0.4), rgba(255, 165, 0, 0.4));
    }
    /* Header with score and pause button */
    #header {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      height: 50px;
      background: #333;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 10px;
      z-index: 10;
    }
    #score, #pauseBtn {
      font-size: 18px;
      cursor: pointer;
      position: relative;
    }
    #pauseBtn {
      user-select: none;
    }
    /* Target pattern visual display as a 3x3 grid */
    #targetPattern {
      position: fixed;
      top: 60px;
      left: 50%;
      transform: translateX(-50%);
      width: 100px;
      height: 100px;
      z-index: 20;
      transform-origin: center center;
    }
    .target-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      grid-gap: 5px;
      width: 100%;
      height: 100%;
    }
    /* Each target circle now has a transition on filter and transform */
    .target-circle {
      border: 2px solid #fff;
      border-radius: 50%;
      background: #333;
      transition: filter 0.3s, transform 0.3s;
    }
    .target-circle.active {
      background: #FFD700;
    }
    /* Explosion animation for target pattern */
    #targetPattern.explode {
      animation: dissolveExplosion 0.2s forwards;
    }
    @keyframes dissolveExplosion {
      0% {
        opacity: 1;
        transform: translateX(-50%) scale(1);
      }
      100% {
        opacity: 0;
        transform: translateX(-50%) scale(calc(1 + var(--firework-potency) * 0.5));
      }
    }
    /* Timer display */
    #timer {
      position: fixed;
      top: 60px;
      right: 10px;
      font-size: 20px;
      padding: 5px 10px;
      background: #444;
      border-radius: 5px;
      z-index: 10;
      overflow: hidden;
    }
    /* Timer increment animation */
    .timer-increment {
      position: absolute;
      top: 0;
      left: 50%;
      transform: translate(-50%, 0);
      font-size: 16px;
      color: #0f0;
      opacity: 1;
      pointer-events: none;
      animation: slideDownFade 0.5s forwards;
    }
    @keyframes slideDownFade {
      0% { transform: translate(-50%, 0); opacity: 1; }
      100% { transform: translate(-50%, 20px); opacity: 0; }
    }
    /* Score increment animation */
    .score-increment {
      position: absolute;
      top: 0;
      left: 50%;
      transform: translate(-50%, 0);
      font-size: 16px;
      color: #0f0;
      opacity: 1;
      pointer-events: none;
      animation: slideDownFade 0.5s forwards;
    }
    /* Timer decrement animation in red */
    .timer-decrement {
      position: absolute;
      top: 0;
      left: 50%;
      transform: translate(-50%, 0);
      font-size: 16px;
      color: red;
      opacity: 1;
      pointer-events: none;
      animation: slideDownFade 0.5s forwards;
    }
    /* Countdown overlay for final seconds */
    #countdownOverlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 15;
      display: none;
      justify-content: center;
      align-items: center;
      pointer-events: none;
    }
    .countdown-number {
      font-size: 100px;
      color: rgba(255, 0, 0, 0.7);
      animation: zoomFade 1s forwards;
    }
    @keyframes zoomFade {
      0% { transform: scale(1); opacity: 1; }
      100% { transform: scale(3); opacity: 0; }
    }
    /* Background flash red animation */
    @keyframes bgFlash {
      0% { background-color: #222; }
      50% { background-color: #331111; }
      100% { background-color: #222; }
    }
    .flash-red {
      animation: bgFlash 0.3s forwards;
    }
    /* Game area */
    #gameArea {
      position: absolute;
      top: 100px;
      bottom: 0;
      left: 0;
      right: 0;
      display: flex;
      justify-content: center;
      align-items: flex-end;
      padding-bottom: 10vh;
      overflow: hidden;
    }
    .grid {
      display: grid;
      grid-template-columns: repeat(3, 80px);
      grid-template-rows: repeat(3, 80px);
      gap: 30px;
      position: relative;
      z-index: 2;
    }
    /* Updated design for game circles */
    .circle {
      width: 80px;
      height: 80px;
      border-radius: 50%;
      background: linear-gradient(#8e8e8e, #444 40%, #444 3%, #282828);
      box-shadow: inset 0 0 8px rgba(255,255,255,0.6), inset 0 0 5px rgba(0,0,0,0.3);
      cursor: pointer;
      user-select: none;
      transition: background 0.2s, transform 0.2s;
      font-size: 0;
      position: relative;
    }
    /* Dot in the middle of the circle */
    .circle::after {
      content: "";
      position: absolute;
      width: 12px;
      height: 12px;
      /* Ensure dot is circular */
      border-radius: 50%;
      background: #fff;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }
    /* Active state: inverted yellow gradient */
    .circle.active {
      background: linear-gradient(#F57F17, #FDD835 3%, #FDD835 40%, #FFF176);
      transform: scale(1.1);
    }
    /* Canvas for drawing lines */
    #lineCanvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
      pointer-events: none;
    }
    /* Overlays for tutorial, settings, pause, game over, and high scores */
    .overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.8);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 40;
    }
    .overlay .content, .tutorial-content, .settings-content, .pause-content, .game-over-content, .highscore-content {
      background: #444;
      padding: 20px;
      border-radius: 10px;
      text-align: center;
      max-width: 80%;
    }
    .overlay button {
      margin-top: 15px;
      padding: 10px 20px;
      font-size: 16px;
      border: none;
      background: #FFD700;
      color: #222;
      cursor: pointer;
      border-radius: 5px;
    }
    /* Leaderboard and Achievements */
    #leaderboard, #achievements {
      display: none; /* Hide these elements but preserve their styles for the overlay versions */
    }
    #leaderboard h2, #achievements h2 {
      font-size: 16px;
      margin-bottom: 5px;
    }
    #leaderboard ul, #achievements ul {
      list-style: none;
    }
    /* Game Over Overlay */
    #gameOverOverlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 25;
      display: none;
      justify-content: center;
      align-items: center;
    }
    /* Highscore Overlay */
    #highscoreOverlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 45;
      display: none;
      justify-content: center;
      align-items: center;
      background: rgba(0,0,0,0.85);
    }
    #highscoreOverlay .highscore-content {
      background: #444;
      padding: 30px;
      border-radius: 10px;
      text-align: left;
      max-width: 500px;
      width: 90%;
    }
    #highscoreOverlay .highscore-content h2 {
      text-align: center;
      margin-bottom: 20px;
      font-size: 24px;
      color: #FFD700;
    }
    #highscoreList {
      text-align: left;
      margin: 20px 0;
      list-style: none;
    }
    #highscoreList li {
      margin: 10px 0;
      font-size: 18px;
      padding: 8px;
      background: rgba(0, 0, 0, 0.2);
      border-radius: 5px;
      transition: background-color 0.2s;
    }
    #highscoreList li:hover {
      background: rgba(0, 0, 0, 0.3);
    }
    #highscoreOverlay .highscore-content button {
      display: block;
      margin: 25px auto 0;
      padding: 12px 30px;
      font-size: 16px;
      border: none;
      background: #FFD700;
      color: #222;
      cursor: pointer;
      border-radius: 5px;
      transition: transform 0.2s, background-color 0.2s;
    }
    #highscoreOverlay .highscore-content button:hover {
      transform: scale(1.05);
      background: #FFC107;
    }
    /* Progress bar styling */
    .progress-container {
      position: fixed;
      top: 170px;
      left: 50%;
      transform: translateX(-50%);
      width: 200px;
      height: 10px;
      background: #444;
      border-radius: 5px;
      overflow: hidden;
      z-index: 20;
    }
    .progress-bar {
      width: 0%;
      height: 100%;
      background: linear-gradient(90deg, #FFD700, #FFA500);
      transition: width 0.3s ease;
    }
    .stage-indicator {
      position: fixed;
      top: 185px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 14px;
      color: #fff;
      z-index: 20;
    }
    /* Multiplier bar container */
    .multiplier-wrapper {
      position: fixed;
      bottom: calc(10vh - 40px);
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .streak-label {
      color: white;
      font-size: 14px;
      font-weight: bold;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
      white-space: nowrap;
    }
    .multiplier-container {
      width: 300px; /* Same as grid width (3 * 80px + 2 * 30px gap) */
      height: 20px;
      background: #444;
      border-radius: 10px;
      overflow: visible;
      display: flex;
      align-items: center;
      position: relative;
    }
    .multiplier-bar {
      height: 100%;
      width: 0%;
      background: #666; /* Default gray color */
      transition: width 0.3s ease, background-color 0.3s ease;
      border-radius: 10px;
    }
    /* Multiplier colors */
    .multiplier-bar.x1 { background: #666; }
    .multiplier-bar.x1-5 { background: #4CAF50; }
    .multiplier-bar.x2 { background: #2196F3; }
    .multiplier-bar.x3 { background: #9C27B0; }
    .multiplier-bar.x4 { 
      background: linear-gradient(90deg, #FFD700, #FFA500);
      box-shadow: 0 0 15px rgba(255, 215, 0, 0.8);
      animation: goldenPulse 1.5s ease-in-out infinite;
    }
    @keyframes goldenPulse {
      0% { 
        box-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
        filter: brightness(1);
      }
      50% { 
        box-shadow: 0 0 25px rgba(255, 215, 0, 0.8);
        filter: brightness(1.3);
      }
      100% { 
        box-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
        filter: brightness(1);
      }
    }
    .multiplier-text {
      position: absolute;
      right: 5px;
      color: white;
      font-size: 14px;
      font-weight: bold;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
    }
    /* Special styling for x4 multiplier text */
    .multiplier-container:has(.multiplier-bar.x4) .multiplier-text {
      color: #FF0000;
      text-shadow: 
        -1px -1px 0 #FFF,
        1px -1px 0 #FFF,
        -1px 1px 0 #FFF,
        1px 1px 0 #FFF,
        0 0 8px rgba(255,255,255,0.8);
    }
    /* Update pause menu to include main menu button */
    .pause-content button {
      display: block;
      width: 200px;
      margin: 15px auto;
    }
    #menuLineCanvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
      pointer-events: none;
    }
    .tutorial-content {
      background: #444;
      padding: 30px;
      border-radius: 10px;
      text-align: left;
      max-width: 500px;
      width: 90%;
    }
    
    .tutorial-content h2 {
      text-align: center;
      margin-bottom: 20px;
      font-size: 24px;
      color: #FFD700;
    }
    
    .tutorial-content p {
      margin: 0;
      line-height: 1.6;
      font-size: 16px;
    }
    
    .tutorial-content button {
      display: block;
      margin: 25px auto 0;
      padding: 12px 30px;
      font-size: 16px;
      border: none;
      background: #FFD700;
      color: #222;
      cursor: pointer;
      border-radius: 5px;
      transition: transform 0.2s, background-color 0.2s;
    }
    
    .tutorial-content button:hover {
      transform: scale(1.05);
      background: #FFC107;
    }
    
    .settings-content {
      background: #444;
      padding: 30px;
      border-radius: 10px;
      text-align: left;
      max-width: 500px;
      width: 90%;
    }
    
    .settings-content h2 {
      text-align: center;
      margin-bottom: 20px;
      font-size: 24px;
      color: #FFD700;
    }
    
    .settings-content label {
      display: block;
      margin: 15px 0;
      font-size: 16px;
      line-height: 1.6;
    }
    
    .settings-content input[type="range"] {
      width: 100%;
      margin: 10px 0;
    }
    
    .settings-content button {
      display: block;
      margin: 25px auto 0;
      padding: 12px 30px;
      font-size: 16px;
      border: none;
      background: #FFD700;
      color: #222;
      cursor: pointer;
      border-radius: 5px;
      transition: transform 0.2s, background-color 0.2s;
    }
    
    .settings-content button:hover {
      transform: scale(1.05);
      background: #FFC107;
    }
    /* Stage complete overlay styling */
    .stage-complete-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 40;
    }
    
    .stage-complete-content {
      background: #444;
      padding: 30px;
      border-radius: 10px;
      text-align: center;
      max-width: 500px;
      width: 90%;
    }
    
    .stage-complete-content h2 {
      color: #FFD700;
      font-size: 24px;
      margin-bottom: 20px;
    }
    
    .stage-complete-content p {
      margin: 10px 0;
      font-size: 16px;
      line-height: 1.6;
    }
    
    .stage-countdown {
      font-size: 72px;
      color: #FFD700;
      margin: 20px 0;
      font-weight: bold;
      animation: pulseScale 1s infinite;
    }
    
    @keyframes pulseScale {
      0% { transform: scale(1); }
      50% { transform: scale(1.2); }
      100% { transform: scale(1); }
    }
  </style>
</head>
<body>
  <!-- Main Menu Overlay -->
  <div id="mainMenu" class="overlay" style="display: flex;">
    <!-- Background animation -->
    <div id="menuBackground">
      <canvas id="menuLineCanvas"></canvas>
      <div id="menuBackgroundGrid">
        <div class="circle" data-index="1"></div>
        <div class="circle" data-index="2"></div>
        <div class="circle" data-index="3"></div>
        <div class="circle" data-index="4"></div>
        <div class="circle" data-index="5"></div>
        <div class="circle" data-index="6"></div>
        <div class="circle" data-index="7"></div>
        <div class="circle" data-index="8"></div>
        <div class="circle" data-index="9"></div>
      </div>
    </div>
    <div class="main-menu-content">
      <div class="main-menu-logo">UNLOCKABLE</div>
      <button id="playBtn">Play</button>
      <button id="instructionsBtn">Instructions</button>
      <button id="optionsBtn">Options</button>
      <button id="viewHighscoresBtnMain">High Scores</button>
    </div>
  </div>
  <!-- Header with score and pause button -->
  <div id="header">
    <div id="score">Score: <span id="scoreCount">0</span></div>
    <div id="pauseBtn">Pause</div>
  </div>
  <!-- Progress bar -->
  <div class="progress-container">
    <div class="progress-bar" id="progressBar"></div>
  </div>
  <div class="stage-indicator" id="stageIndicator">Stage 1</div>
  <!-- Target pattern visual display -->
  <div id="targetPattern">
    <div class="target-grid">
      <div class="target-circle" data-index="1"></div>
      <div class="target-circle" data-index="2"></div>
      <div class="target-circle" data-index="3"></div>
      <div class="target-circle" data-index="4"></div>
      <div class="target-circle" data-index="5"></div>
      <div class="target-circle" data-index="6"></div>
      <div class="target-circle" data-index="7"></div>
      <div class="target-circle" data-index="8"></div>
      <div class="target-circle" data-index="9"></div>
    </div>
  </div>
  <!-- Timer display -->
  <div id="timer">
    Time: <span id="timerCount">25</span>
  </div>
  <!-- Countdown overlay for final seconds -->
  <div id="countdownOverlay">
    <div class="countdown-number" id="countdownNumber"></div>
  </div>
  <!-- Game Area -->
  <div id="gameArea">
    <canvas id="lineCanvas"></canvas>
    <div class="grid">
      <div class="circle" data-index="1"></div>
      <div class="circle" data-index="2"></div>
      <div class="circle" data-index="3"></div>
      <div class="circle" data-index="4"></div>
      <div class="circle" data-index="5"></div>
      <div class="circle" data-index="6"></div>
      <div class="circle" data-index="7"></div>
      <div class="circle" data-index="8"></div>
      <div class="circle" data-index="9"></div>
    </div>
  </div>
  <!-- Multiplier bar moved outside header -->
  <div class="multiplier-wrapper">
    <div class="streak-label">Streak:</div>
    <div class="multiplier-container">
      <div class="multiplier-bar"></div>
      <div class="multiplier-text">1x</div>
    </div>
  </div>
  <!-- Tutorial/Onboarding Screen -->
  <div id="tutorial" class="overlay">
    <div class="tutorial-content content">
      <h2>Instructions</h2>
      <p>
        Connect the circles in the pattern shown at the top of the screen. The pattern shows the order in which you need to connect the circles.
      </p>
      <p>
        When you make a correct pattern, you'll earn points based on the pattern length and your current multiplier. You'll also get a 0.5 second time bonus.
      </p>
      <p>
        Be careful though! Wrong patterns will cost you 0.5 seconds and reset your streak multiplier.
      </p>
      <button id="closeTutorial">Got it!</button>
    </div>
  </div>
  <!-- Settings Menu -->
  <div id="settings" class="overlay">
    <div class="settings-content content">
      <h2>Settings</h2>
      <label>
        <input type="checkbox" id="soundToggle" checked> Sound
      </label>
      <br><br>
      <label>
        Volume:
        <input type="range" id="volumeControl" min="0" max="1" step="0.1" value="1">
      </label>
      <br><br>
      <button id="closeSettings">Close</button>
    </div>
  </div>
  <!-- Game Over Overlay -->
  <div id="gameOverOverlay" class="overlay">
    <div class="game-over-content content">
      <h2>Game Over</h2>
      <p id="finalScore"></p>
      <p id="finalHighScore"></p>
      <!-- Input for submitting high score -->
      <input type="text" id="playerName" placeholder="Enter your name">
      <button id="submitHighscoreBtn">Submit Score</button>
      <button id="retryBtn">Retry</button>
    </div>
  </div>
  <!-- Pause Overlay with Main Menu option -->
  <div id="pauseOverlay" class="overlay">
    <div class="pause-content content">
      <h2>Game Paused</h2>
      <button id="resumeBtn">Resume</button>
      <button id="retryPauseBtn">Retry</button>
      <button id="viewHighscoresBtnPauseOverlay">High Scores</button>
      <button id="mainMenuBtn">Main Menu</button>
    </div>
  </div>
  <!-- Highscore Overlay -->
  <div id="highscoreOverlay" class="overlay">
    <div class="highscore-content content">
      <h2>High Scores</h2>
      <ul id="highscoreList"></ul>
      <button id="closeHighscoreBtn">Close</button>
    </div>
  </div>
  <!-- Leaderboard -->
  <div id="leaderboard">
    <h2>Leaderboard</h2>
    <ul id="leaderboardList"></ul>
  </div>
  <!-- Achievements -->
  <div id="achievements">
    <h2>Achievements</h2>
    <ul id="achievementsList"></ul>
  </div>
  <script type="module">
    // Import Firebase helpers from external file.
    import { submitHighScore, getTopHighScores, submitTimingData } from './firebase-config.js';

    // Global variables and game settings
    let score = 0;
    let drawnPattern = [];
    let currentStage = 1;
    let progress = 0;

    // Streak system variables
    let streak = 0;
    let multiplier = 1;
    const STREAK_THRESHOLD = 8;
    const MULTIPLIER_LEVELS = [
      { threshold: 0, value: 1, class: 'x1' },
      { threshold: 8, value: 1.5, class: 'x1-5' },
      { threshold: 16, value: 2, class: 'x2' },
      { threshold: 24, value: 3, class: 'x3' },
      { threshold: 32, value: 4, class: 'x4' }
    ];

    // Timing analysis data
    const timingData = {
      patterns: [],
      currentPatternStart: 0,
      stageStartTime: 0,
      stageData: {}
    };

    // Add after the timingData declaration
    let currentGameId = null;

    // Calculate pattern complexity (more jumps and turns = more complex)
    function calculatePatternComplexity(pattern) {
      let complexity = 0;
      for (let i = 1; i < pattern.length; i++) {
        const prev = pattern[i - 1];
        const curr = pattern[i];
        // Check for jumps (non-adjacent nodes)
        if (!getIntermediate(prev, curr)) {
          const prevRow = Math.floor((prev - 1) / 3);
          const prevCol = (prev - 1) % 3;
          const currRow = Math.floor((curr - 1) / 3);
          const currCol = (curr - 1) % 3;
          const distance = Math.sqrt(Math.pow(currRow - prevRow, 2) + Math.pow(currCol - prevCol, 2));
          complexity += distance;
        }
        // Check for direction changes
        if (i > 1) {
          const prevPrev = pattern[i - 2];
          const angle = calculateAngle(prevPrev, prev, curr);
          complexity += angle / 45; // Normalize angle contribution
        }
      }
      return complexity;
    }

    // Calculate angle between three points
    function calculateAngle(p1, p2, p3) {
      const p1Row = Math.floor((p1 - 1) / 3);
      const p1Col = (p1 - 1) % 3;
      const p2Row = Math.floor((p2 - 1) / 3);
      const p2Col = (p2 - 1) % 3;
      const p3Row = Math.floor((p3 - 1) / 3);
      const p3Col = (p3 - 1) % 3;
      
      const angle1 = Math.atan2(p1Row - p2Row, p1Col - p2Col);
      const angle2 = Math.atan2(p3Row - p2Row, p3Col - p2Col);
      let angle = Math.abs((angle1 - angle2) * 180 / Math.PI);
      if (angle > 180) angle = 360 - angle;
      return angle;
    }

    // Start timing a new pattern attempt
    function startPatternTiming() {
      timingData.currentPatternStart = performance.now();
    }

    // Record pattern completion data
    function recordPatternCompletion(success) {
      const endTime = performance.now();
      const duration = endTime - timingData.currentPatternStart;
      
      const patternData = {
        stage: currentStage,
        pattern: [...currentTarget],
        length: currentTarget.length,
        complexity: calculatePatternComplexity(currentTarget),
        duration: duration,
        success: success,
        remainingTime: remainingTime,
        score: score,
        timestamp: endTime
      };
      
      // Add to overall patterns
      timingData.patterns.push(patternData);
      
      // Ensure stage data exists and update it
      if (!timingData.stageData[currentStage]) {
        timingData.stageData[currentStage] = {
          attempts: 0,
          successes: 0,
          totalTime: 0,
          patterns: [],
          timeLimit: stageConfigs[currentStage].time,
          requiredPatterns: stageConfigs[currentStage].requiredPatterns,
          startTime: Date.now()
        };
      }
      
      const stageStats = timingData.stageData[currentStage];
      stageStats.attempts++;
      if (success) {
        stageStats.successes++;
        stageStats.totalTime += duration;
      }
      stageStats.patterns.push(patternData);
    }

    // Replace the stageConfigs and stagePatterns declarations with:
    let stageConfigs = {};
    let patterns = [];

    // Add this function to load the levels data
    async function loadLevels() {
        try {
            const response = await fetch('levels.json', {
                cache: 'no-store', // Forces a network request instead of using cache
                headers: {
                    'Cache-Control': 'no-cache',
                    'Pragma': 'no-cache'
                }
            });
            
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            const data = await response.json();
            
            // Validate the data structure
            if (!data.stageConfigs || !data.stagePatterns) {
                throw new Error('Invalid levels data structure');
            }

            // Validate that we have at least stage 1 data
            if (!data.stageConfigs[1] || !data.stagePatterns[1]) {
                throw new Error('Missing stage 1 configuration');
            }

            stageConfigs = data.stageConfigs;
            patterns = data.stagePatterns[1]; // Initialize with stage 1 patterns

            return true;
        } catch (error) {
            console.error('Error loading levels:', error);
            alert('Error loading game levels. Please ensure levels.json is properly configured.');
            return false;
        }
    }

    // Modify the play button click handler to prevent game start if levels fail to load
    document.getElementById("playBtn").addEventListener("click", async () => {
        stopMenuAnimation();
        
        // Load levels before starting the game
        const levelsLoaded = await loadLevels();
        if (!levelsLoaded) {
            // Return to main menu if levels failed to load
            document.getElementById("mainMenu").style.display = "flex";
            startMenuAnimation();
            return;
        }
        
        document.getElementById("mainMenu").style.display = "none";
        preloadSounds();
        updateMultiplierBarWidth();
        generateTarget();
        startTimer(true);
    });

    // Modify the updateProgress function to check for valid stage data
    function updateProgress() {
        const progressBar = document.getElementById('progressBar');
        const stageIndicator = document.getElementById('stageIndicator');
        progressBar.style.width = progress + '%';
        
        if (progress >= 100) {
            const nextStage = currentStage + 1;
            if (patterns[nextStage] && stageConfigs[nextStage]) {
                currentStage = nextStage;
                patterns = patterns[currentStage];
                progress = 0;
                progressBar.style.width = '0%';
                stageIndicator.textContent = `Stage ${currentStage}`;
                
                // Initialize new stage data
                timingData.stageData[currentStage] = {
                    attempts: 0,
                    successes: 0,
                    totalTime: 0,
                    patterns: [],
                    timeLimit: stageConfigs[currentStage].time,
                    requiredPatterns: stageConfigs[currentStage].requiredPatterns,
                    startTime: Date.now()
                };
                
                showStageComplete();
            } else {
                showGameComplete();
            }
        }
    }

    // Modify the startTimer function to properly handle the timer countdown
    function startTimer(reset = true) {
        if (reset) { 
            const stageConfig = stageConfigs[currentStage];
            if (!stageConfig) {
                alert('Error: Could not load stage configuration. Please refresh the page.');
                return;
            }
            timerDuration = stageConfig.time;
            remainingTime = timerDuration;
            
            if (!currentGameId) {
                currentGameId = Date.now().toString();
                timingData.gameStartTime = Date.now();
            }
        }
        
        clearInterval(timerInterval);
        timerInterval = setInterval(() => {
            remainingTime -= 1;
            updateTimerDisplay();
            
            // End game when time reaches 0 (not negative)
            if (remainingTime <= 0) {
                clearInterval(timerInterval);
                remainingTime = 0; // Ensure we don't show negative time
                updateTimerDisplay();
                gameOver();
            }
        }, 1000);
    }

    // Pattern lists for each stage
    let stagePatterns = {
      1: [ // Simple lines and diagonals (no changes needed - these are all valid)
        [1,2,3], [3,2,1], [4,5,6], [6,5,4],
        [7,8,9], [9,8,7], [1,4,7], [7,4,1],
        [2,5,8], [8,5,2], [3,6,9], [9,6,3],
        [1,5,9], [9,5,1], [3,5,7], [7,5,3]
      ],
      2: [ // 4-node patterns (revised to avoid auto-activation conflicts)
        [1,2,3,6], [3,2,1,4], [7,8,9,6], [9,8,7,4],
        [1,4,7,8], [7,4,1,2], [1,2,5,9], [3,6,5,7],
        [7,4,5,3], [9,6,5,1], [1,4,5,9], [3,6,5,7],
        [2,5,6,9], [4,5,8,7], [8,5,4,1], [2,5,6,9]
      ],
      3: [ // 5-node patterns with zigzags (revised)
        [1,2,3,6,9], [9,6,3,2,1], [7,8,9,6,3],
        [1,4,7,8,9], [3,2,1,4,7], [9,8,7,4,1],
        [1,2,5,8,9], [3,6,5,4,1], [7,4,5,6,9],
        [9,8,5,2,1], [1,4,5,6,9], [7,8,5,2,1]
      ],
      4: [ // Complex 5-node patterns (completely revised to avoid center conflicts)
        [1,2,5,8,7], [3,6,5,4,1], [9,8,5,2,3],
        [7,4,5,6,9], [1,4,5,8,9], [3,2,5,4,7],
        [9,6,5,2,1], [7,8,5,6,3], [1,2,5,6,7],
        [3,2,5,8,9], [7,4,5,2,3], [9,8,5,4,1]
      ],
      5: [ // 6-node patterns (revised)
        [1,2,5,8,7,4], [3,6,5,4,1,2], [9,8,5,2,1,4],
        [7,4,5,6,9,8], [1,4,5,8,9,6], [3,2,5,4,7,8],
        [9,6,5,2,1,4], [7,8,5,6,3,2], [1,2,5,6,9,8],
        [3,2,5,8,7,4], [9,6,5,4,1,2], [7,4,5,2,3,6]
      ],
      6: [ // Complex 6-node patterns with strategic jumps (revised)
        [1,2,5,9,6,3], [7,4,5,3,2,1], [9,8,5,1,4,7],
        [3,6,5,7,8,9], [1,4,5,9,6,3], [7,8,5,1,2,3],
        [9,6,5,1,4,7], [3,2,5,7,8,9], [1,4,5,3,6,9],
        [7,8,5,3,2,1], [9,6,5,7,4,1], [3,2,5,9,8,7]
      ],
      7: [ // 7-node patterns (revised)
        [1,2,5,9,6,3,4], [7,4,5,3,2,1,8], [9,8,5,1,4,7,6],
        [3,6,5,7,8,9,2], [1,4,5,9,6,3,8], [7,8,5,1,2,3,6],
        [9,6,5,1,4,7,2], [3,2,5,7,8,9,4], [1,4,5,3,6,9,8],
        [7,8,5,3,2,1,6], [9,6,5,7,4,1,2], [3,2,5,9,8,7,4]
      ],
      8: [ // 8-node patterns (revised)
        [1,2,5,9,6,3,4,7], [7,4,5,3,2,1,8,9], [9,8,5,1,4,7,6,3],
        [3,6,5,7,8,9,2,1], [1,4,5,9,6,3,8,7], [7,8,5,1,2,3,6,9],
        [9,6,5,1,4,7,2,3], [3,2,5,7,8,9,4,1], [1,4,5,3,6,9,8,7],
        [7,8,5,3,2,1,6,9], [9,6,5,7,4,1,2,3], [3,2,5,9,8,7,4,1]
      ],
      9: [ // 9-node patterns (revised to ensure all moves are possible)
        [1,2,5,9,6,3,4,7,8], [7,4,5,3,2,1,8,9,6], [9,8,5,1,4,7,6,3,2],
        [3,6,5,7,8,9,2,1,4], [1,4,5,9,6,3,8,7,2], [7,8,5,1,2,3,6,9,4],
        [9,6,5,1,4,7,2,3,8], [3,2,5,7,8,9,4,1,6], [1,4,5,3,6,9,8,7,2],
        [7,8,5,3,2,1,6,9,4], [9,6,5,7,4,1,2,3,8], [3,2,5,9,8,7,4,1,6]
      ],
      10: [ // Ultimate challenge patterns (revised)
        [1,2,5,9,6,3,4,7,8], [3,2,5,7,4,1,8,9,6], [9,8,5,1,4,7,6,3,2],
        [7,4,5,3,6,9,2,1,8], [1,4,5,9,8,7,2,3,6], [3,6,5,1,2,7,8,9,4],
        [9,8,5,3,2,1,4,7,6], [7,4,5,9,6,3,2,1,8], [1,2,5,7,8,9,6,3,4],
        [3,6,5,9,8,7,2,1,4], [9,8,5,1,2,3,6,7,4], [7,4,5,3,6,9,8,1,2]
      ]
    };

    let currentTarget = [];
    
    // Set initial timer duration based on current stage
    let timerDuration = 20; // Default time
    let timerInterval = null;
    let remainingTime = timerDuration;
    
    // Audio settings
    let soundEnabled = true;
    let volume = 1;
    
    // New variables for dynamic hit percentages
    const ACTIVE_HIT_PERCENTAGE = 1;
    const INACTIVE_HIT_PERCENTAGE = 0.6;
    
    // Sound pool configuration
    const SOUND_POOL_SIZE = 4;
    const soundPools = {
      tap: Array(SOUND_POOL_SIZE).fill(null).map(() => new Audio("audio/tap.wav")),
      correct: Array(SOUND_POOL_SIZE).fill(null).map(() => new Audio("audio/correct.wav")),
      incorrect: Array(SOUND_POOL_SIZE).fill(null).map(() => new Audio("audio/incorrect.wav"))
    };
    const soundPoolIndexes = {
      tap: 0,
      correct: 0,
      incorrect: 0
    };

    // Preload sounds with very low volume to handle mobile autoplay restrictions
    function preloadSounds() {
      Object.values(soundPools).flat().forEach(audio => {
        audio.volume = 0.01;
        audio.play().then(() => {
          audio.pause();
          audio.currentTime = 0;
        }).catch(() => {
          // Ignore autoplay errors
        });
      });
    }
    
    // Helper function to play a sound by type using sound pool
    function playSound(type) {
      if (!soundEnabled || !soundPools[type]) return;
      
      const pool = soundPools[type];
      let audio = pool[soundPoolIndexes[type]];
      
      // Reset audio if it's still playing
      if (!audio.paused) {
        audio.pause();
        audio.currentTime = 0;
      }
      
      audio.volume = volume;
      audio.play().catch(() => {
        // Ignore playback errors on mobile
      });
      
      // Update pool index for next use
      soundPoolIndexes[type] = (soundPoolIndexes[type] + 1) % SOUND_POOL_SIZE;
    }
    
    // Helper to animate time subtraction in red.
    function animateTimerDecrement() {
      const timerElem = document.getElementById("timer");
      const decElem = document.createElement("span");
      decElem.className = "timer-decrement";
      decElem.textContent = "-0.5";
      timerElem.appendChild(decElem);
      setTimeout(() => { timerElem.removeChild(decElem); }, 500);
    }
    
    // Helper function to flash the background in dark red.
    function flashBackground() {
      document.body.classList.add("flash-red");
      setTimeout(() => { document.body.classList.remove("flash-red"); }, 300);
    }
    
    // Explosion potency (relative to 40px radius)
    const FIREWORK_POTENCY = 1;
    
    // Helper: Get intermediate node if exactly in line.
    function getIntermediate(last, candidate) {
      let lastRow = Math.floor((last - 1) / 3);
      let lastCol = (last - 1) % 3;
      let candRow = Math.floor((candidate - 1) / 3);
      let candCol = (candidate - 1) % 3;
      if ((lastRow + candRow) % 2 === 0 && (lastCol + candCol) % 2 === 0) {
        let midRow = (lastRow + candRow) / 2;
        let midCol = (lastCol + candCol) / 2;
        let midIndex = midRow * 3 + midCol + 1;
        if (midIndex !== last && midIndex !== candidate) {
          return midIndex;
        }
      }
      return null;
    }
    
    // Update UI: score and target pattern display.
    function updateUI() {
      document.getElementById('scoreCount').textContent = score;
      updateTargetDisplay();
    }
    
    // Update the target pattern display.
    function updateTargetDisplay() {
      const circles = document.querySelectorAll('#targetPattern .target-circle');
      circles.forEach(circle => {
        circle.classList.remove('active');
        circle.style.filter = '';
        circle.style.transform = 'scale(1)';
      });
      currentTarget.forEach((val, idx) => {
        let circle = document.querySelector(`#targetPattern .target-circle[data-index="${val}"]`);
        if (circle) {
          circle.classList.add('active');
          let brightness = (currentTarget.length > 1) ? 1 - (idx * (0.7 / (currentTarget.length - 1))) : 1;
          let scale = (currentTarget.length > 1) ? 1 - (idx * (0.4 / (currentTarget.length - 1))) : 1;
          let maxHue = 120;
          let hue = (currentTarget.length > 1) ? (idx / (currentTarget.length - 1) * maxHue) : 0;
          circle.style.filter = `brightness(${brightness}) hue-rotate(${hue}deg)`;
          circle.style.transform = `scale(${scale})`;
        }
      });
    }
    
    // Generate new target pattern.
    function generateTarget() {
      currentTarget = patterns[Math.floor(Math.random() * patterns.length)];
      updateUI();
      resetDrawing();
      startPatternTiming();
    }
    
    // Reset drawn pattern and clear states.
    function resetDrawing() {
      drawnPattern = [];
      clearCanvas();
      document.querySelectorAll('.circle').forEach(circle => {
        circle.classList.remove('active');
      });
    }
    
    // Canvas for drawing lines.
    const canvas = document.getElementById("lineCanvas");
    const ctx = canvas.getContext("2d");
    
    function resizeCanvas() {
      const gameArea = document.getElementById("gameArea");
      canvas.width = gameArea.offsetWidth;
      canvas.height = gameArea.offsetHeight;
      canvas.style.width = '100%';
      canvas.style.height = '100%';
      drawLines(); // Redraw lines after resize
    }
    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();
    
    // Get center coordinates of a circle element.
    function getCircleCenter(circle) {
      const rect = circle.getBoundingClientRect();
      const gameArea = document.getElementById("gameArea");
      const gameAreaRect = gameArea.getBoundingClientRect();
      return {
        x: rect.left + rect.width / 2 - gameAreaRect.left,
        y: rect.top + rect.height / 2 - gameAreaRect.top
      };
    }
    
    // Clear canvas.
    function clearCanvas() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
    }
    
    // Draw connecting lines.
    let currentPointer = null;
    function drawLines() {
      clearCanvas();
      if (drawnPattern.length === 0) return;
      
      ctx.lineWidth = 5;
      ctx.strokeStyle = "#FFD700";
      ctx.beginPath();
      
      const gameArea = document.getElementById("gameArea");
      const gameAreaRect = gameArea.getBoundingClientRect();
      
      for (let i = 0; i < drawnPattern.length; i++) {
        const circle = document.querySelector(`#gameArea .circle[data-index="${drawnPattern[i]}"]`);
        if (!circle) continue;
        
        const center = getCircleCenter(circle);
        if (i === 0) {
          ctx.moveTo(center.x, center.y);
        } else {
          ctx.lineTo(center.x, center.y);
        }
      }
      
      if (currentPointer) {
        ctx.lineTo(currentPointer.x, currentPointer.y);
      }
      
      ctx.stroke();
    }
    
    // When input is complete, check pattern validity.
    function checkPattern() {
      let target = currentTarget;
      let drawn = drawnPattern;
      let j = 0;
      for (let i = 0; i < drawn.length && j < target.length; i++) {
        if (drawn[i] === target[j]) { j++; }
      }
      return j === target.length;
    }
    
    // Check for an exact match.
    function checkExact() {
      if (drawnPattern.length !== currentTarget.length) return false;
      for (let i = 0; i < currentTarget.length; i++) {
        if (drawnPattern[i] !== currentTarget[i]) return false;
      }
      return true;
    }
    
    // Update multiplier bar width based on target pattern width
    function updateMultiplierBarWidth() {
      const targetPattern = document.getElementById('targetPattern');
      const multiplierContainer = document.querySelector('.multiplier-container');
      if (targetPattern && multiplierContainer) {
        const targetWidth = targetPattern.offsetWidth;
        multiplierContainer.style.width = (targetWidth * 1.1) + 'px';
      }
    }

    // Update streak and multiplier
    function updateStreak(success) {
      if (!success) {
        streak = 0;
        multiplier = 1;
      } else {
        streak++;
      }
      
      // Update multiplier based on streak
      for (let i = MULTIPLIER_LEVELS.length - 1; i >= 0; i--) {
        if (streak >= MULTIPLIER_LEVELS[i].threshold) {
          multiplier = MULTIPLIER_LEVELS[i].value;
          updateMultiplierBar(MULTIPLIER_LEVELS[i].class);
          break;
        }
      }
    }

    // Update multiplier bar visual
    function updateMultiplierBar(className) {
      const bar = document.querySelector('.multiplier-bar');
      const text = document.querySelector('.multiplier-text');
      
      // Remove all multiplier classes
      MULTIPLIER_LEVELS.forEach(level => bar.classList.remove(level.class));
      // Add current multiplier class
      bar.classList.add(className);
      
      // If at x4 multiplier (className is 'x4'), keep bar at 100%
      if (className === 'x4') {
        bar.style.width = '100%';
      } else {
        // Otherwise, show progress to next threshold
        const progress = (streak % STREAK_THRESHOLD) / STREAK_THRESHOLD * 100;
        bar.style.width = progress + '%';
      }
      
      text.textContent = multiplier + 'x';
    }

    // When input is complete, check pattern validity.
    function completePattern() {
      let isValid = false;
      if (drawnPattern.length === currentTarget.length) {
        isValid = true;
        for (let i = 0; i < currentTarget.length; i++) {
          if (drawnPattern[i] !== currentTarget[i]) {
            isValid = false;
            break;
          }
        }
      }
      
      recordPatternCompletion(isValid);
      updateStreak(isValid);
      
      if (isValid) {
        const basePoints = currentTarget.length * 5;
        const pointsGained = Math.round(basePoints * multiplier);
        score += pointsGained;
        if (soundEnabled) { 
          playSound("correct");
        }
        remainingTime += 0.5;
        updateTimerDisplay();
        animateTimerIncrement();
        animateScoreIncrement(pointsGained);
        progress += (100 / stageConfigs[currentStage].requiredPatterns);
        updateProgress();
        animateSuccess();
      } else {
        remainingTime -= 0.5;
        if (soundEnabled) { 
          playSound("incorrect");
        }
        animateTimerDecrement();
        flashBackground();
        updateTimerDisplay();
        resetDrawing();
        startPatternTiming(); // Start timing the next attempt
      }
    }
    
    // Animate target explosion and generate new target.
    function animateSuccess() {
      const targetElement = document.getElementById("targetPattern");
      targetElement.style.setProperty('--firework-potency', FIREWORK_POTENCY);
      targetElement.classList.add("explode");
      targetElement.addEventListener("animationend", function handler() {
        targetElement.classList.remove("explode");
        targetElement.removeEventListener("animationend", handler);
        // Only generate new target if we're not at stage completion
        if (progress < 100) {
          generateTarget();
        }
      });
      resetDrawing();
    }
    
    // Update timer display.
    function updateTimerDisplay() {
        // Show 0 instead of negative numbers
        const timeToShow = Math.max(0, Math.ceil(remainingTime));
        document.getElementById("timerCount").textContent = timeToShow;
        
        // Show countdown overlay for numbers 5 through 1
        if (remainingTime > 0 && remainingTime <= 5) {
            showCountdown(Math.ceil(remainingTime));
        } else {
            document.getElementById("countdownOverlay").style.display = "none";
        }
    }
    
    // Animate the +0.5 timer increment.
    function animateTimerIncrement() {
      const timerElem = document.getElementById("timer");
      const incElem = document.createElement("span");
      incElem.className = "timer-increment";
      incElem.textContent = "+0.5";
      timerElem.appendChild(incElem);
      setTimeout(() => { timerElem.removeChild(incElem); }, 500);
    }
    
    // Animate the score increment.
    function animateScoreIncrement(points) {
      const scoreElem = document.getElementById("score");
      const incElem = document.createElement("span");
      incElem.className = "score-increment";
      incElem.textContent = `+${points}`;
      scoreElem.appendChild(incElem);
      setTimeout(() => { scoreElem.removeChild(incElem); }, 500);
    }
    
    // (animateTimerDecrement and flashBackground are declared above, only once)
    
    // Countdown overlay: show large countdown numbers.
    function showCountdown(num) {
      const overlay = document.getElementById("countdownOverlay");
      const numberElem = document.getElementById("countdownNumber");
      numberElem.textContent = num;
      numberElem.style.animation = 'none';
      numberElem.offsetHeight;
      numberElem.style.animation = 'zoomFade 1s forwards';
      overlay.style.display = "flex";
    }
    
    // Hitbox settings for circles
    const CIRCLE_DIAMETER = 80;
    const CIRCLE_RADIUS = CIRCLE_DIAMETER / 2;
    
    // Game Over: show game over overlay.
    function gameOver() {
      clearInterval(timerInterval);
      
      // Update final stage data
      const finalStageData = timingData.stageData[currentStage];
      if (finalStageData) {
        finalStageData.endTime = Date.now();
        finalStageData.finalRemainingTime = remainingTime;
        finalStageData.completed = remainingTime > 0;
      }
      
      // Add final game stats to timing data
      timingData.finalScore = score;
      timingData.finalStage = currentStage;
      timingData.gameDuration = Date.now() - timingData.gameStartTime;
      
      // Submit final game data to Firebase
      submitTimingData(currentGameId, {
        ...timingData,
        gameComplete: false,
        endReason: remainingTime <= 0 ? 'timeout' : 'incomplete'
      })
      .then(() => {
        console.log('Final game stats saved successfully');
      })
      .catch((error) => {
        console.error('Error saving final game stats:', error);
      });
      
      document.getElementById("finalScore").textContent = "Score: " + score;
      let highScore = localStorage.getItem("highScore") || 0;
      if (score > highScore) { 
        localStorage.setItem("highScore", score);
        highScore = score;
      }
      document.getElementById("finalHighScore").textContent = "High Score: " + highScore;
      document.getElementById("gameOverOverlay").style.display = "flex";
      resetDrawing();
    }
    
    // Input handling (mouse and touch)
    let isDrawing = false;
    const gameArea = document.getElementById("gameArea");
    
    function handleStart(e) {
      e.preventDefault();
      isDrawing = true;
      currentPointer = null;
      let target = e.target;
      if (target.classList.contains("circle")) {
        const index = parseInt(target.getAttribute("data-index"));
        if (!drawnPattern.includes(index)) {
          drawnPattern.push(index);
          target.classList.add("active");
          if (soundEnabled) {
            playSound("tap");
          }
        }
      }
    }
    
    function handleMove(e) {
      if (!isDrawing) return;
      let clientX, clientY;
      if (e.touches) {
        clientX = e.touches[0].clientX;
        clientY = e.touches[0].clientY;
      } else {
        clientX = e.clientX;
        clientY = e.clientY;
      }
      
      const gameArea = document.getElementById("gameArea");
      const gameAreaRect = gameArea.getBoundingClientRect();
      currentPointer = {
        x: clientX - gameAreaRect.left,
        y: clientY - gameAreaRect.top
      };
      
      const circles = document.querySelectorAll('#gameArea .circle');
      for (let i = 0; i < circles.length; i++) {
        let circle = circles[i];
        let index = parseInt(circle.getAttribute("data-index"));
        if (drawnPattern.includes(index)) continue;
        const rect = circle.getBoundingClientRect();
        
        // If no circle has been pressed yet, use bounding box check
        if (drawnPattern.length === 0) {
            if (clientX >= rect.left && clientX <= rect.right &&
                clientY >= rect.top && clientY <= rect.bottom) {
                drawnPattern.push(index);
                circle.classList.add("active");
                if (soundEnabled) {
                    playSound("tap");
                }
            }
        } else {
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            const dx = clientX - centerX;
            const dy = clientY - centerY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            let nextTarget = currentTarget[drawnPattern.length];
            let dynamicHitPercentage = (index === nextTarget) ? ACTIVE_HIT_PERCENTAGE : INACTIVE_HIT_PERCENTAGE;
            let threshold = CIRCLE_RADIUS * dynamicHitPercentage;
            
            if (distance <= threshold) {
                let last = drawnPattern[drawnPattern.length - 1];
                
                // First check for intermediate circle
                let intermediate = getIntermediate(last, index);
                if (intermediate && !drawnPattern.includes(intermediate)) {
                    // Change the selector to be more specific and verify the element is found
                    const intermediateCircle = document.querySelector(`#gameArea .grid .circle[data-index="${intermediate}"]`);
                    if (intermediateCircle) {
                        drawnPattern.push(intermediate);
                        // Force immediate activation
                        requestAnimationFrame(() => {
                            intermediateCircle.classList.add("active");
                            if (soundEnabled) {
                                playSound("tap");
                            }
                        });
                        drawLines(); // Update lines after adding intermediate
                    }
                }
                
                // Then add the target circle
                drawnPattern.push(index);
                circle.classList.add("active");
                if (soundEnabled) {
                    playSound("tap");
                }
                drawLines(); // Update lines after adding target
                break; // Exit the loop after adding circles
            }
        }
      }
      drawLines();
    }
    
    function handleEnd(e) {
      if (!isDrawing) return;
      isDrawing = false;
      currentPointer = null;
      drawLines();
      // Only check pattern if the user drew something
      if (drawnPattern.length > 0) {
        completePattern();
      }
    }
    
    gameArea.addEventListener("mousedown", handleStart);
    gameArea.addEventListener("mousemove", handleMove);
    gameArea.addEventListener("mouseup", handleEnd);
    gameArea.addEventListener("mouseleave", handleEnd);
    gameArea.addEventListener("touchstart", handleStart);
    gameArea.addEventListener("touchmove", handleMove);
    gameArea.addEventListener("touchend", handleEnd);
    
    // Pause functionality
    const pauseBtn = document.getElementById("pauseBtn");
    const pauseOverlay = document.getElementById("pauseOverlay");
    pauseBtn.addEventListener("click", pauseGame);
    document.getElementById("resumeBtn").addEventListener("click", resumeGame);
    document.getElementById("retryPauseBtn").addEventListener("click", () => {
      pauseOverlay.style.display = "none";
      restartGame();
    });
    // New button in Pause overlay to view high scores
    document.getElementById("viewHighscoresBtnPauseOverlay").addEventListener("click", () => {
      openHighscoreOverlay();
    });
    
    function pauseGame() {
      clearInterval(timerInterval);
      pauseOverlay.style.display = "flex";
    }
    
    function resumeGame() {
      pauseOverlay.style.display = "none";
      startTimer(false);
    }
    
    // Tutorial/Onboarding: instructions overlay.
    const tutorial = document.getElementById("tutorial");
    const closeTutorial = document.getElementById("closeTutorial");
    closeTutorial.addEventListener("click", () => {
      document.getElementById("tutorial").style.display = "none";
      document.getElementById("mainMenu").style.display = "flex";
      startMenuAnimation(); // Restart menu animation when returning
    });
    
    // Main Menu navigation
    document.getElementById("playBtn").addEventListener("click", async () => {
      stopMenuAnimation();
      
      // Load levels before starting the game
      const levelsLoaded = await loadLevels();
      if (!levelsLoaded) {
          // Return to main menu if levels failed to load
          document.getElementById("mainMenu").style.display = "flex";
          startMenuAnimation();
          return;
      }
      
      document.getElementById("mainMenu").style.display = "none";
      preloadSounds();
      updateMultiplierBarWidth();
      generateTarget();
      startTimer(true);
    });

    document.getElementById("instructionsBtn").addEventListener("click", () => {
      stopMenuAnimation();
      document.getElementById("mainMenu").style.display = "none";
      document.getElementById("tutorial").style.display = "flex";
    });

    document.getElementById("optionsBtn").addEventListener("click", () => {
      document.getElementById("settings").style.display = "flex";
    });
    
    // Open highscore overlay from main menu button
    document.getElementById("viewHighscoresBtnMain").addEventListener("click", () => {
      openHighscoreOverlay();
    });
    
    document.getElementById("closeHighscoreBtn").addEventListener("click", () => {
      document.getElementById("highscoreOverlay").style.display = "none";
    });
    
    // Game Over highscore submission and display
    document.getElementById("submitHighscoreBtn").addEventListener("click", () => {
      const playerName = document.getElementById("playerName").value.trim();
      if (playerName === "") {
        alert("Please enter your name.");
        return;
      }
      submitHighScore(playerName, score)
        .then(() => {
          openHighscoreOverlay();
        })
        .catch((error) => {
          console.error("Error submitting highscore:", error);
        });
    });
    
    document.getElementById("retryBtn").addEventListener("click", () => {
      document.getElementById("gameOverOverlay").style.display = "none";
      restartGame();
    });
    
    function restartGame() {
      currentGameId = null; // Reset the game ID for a new game
      score = 0;
      currentStage = 1;
      progress = 0;
      streak = 0;
      multiplier = 1;
      patterns = stagePatterns[1] || [[1,2,3], [3,2,1]]; // Use fallback only if needed
      remainingTime = stageConfigs[1]?.time || 20; // Use fallback time if needed
      updateTimerDisplay();
      updateUI();
      updateProgress();
      updateMultiplierBar('x1');
      document.getElementById('stageIndicator').textContent = `Stage ${currentStage}`;
      generateTarget();
      startTimer(true);
    }
    
    function openHighscoreOverlay() {
      // Retrieve top 5 highscores and display them.
      getTopHighScores((highscores) => {
        const listEl = document.getElementById("highscoreList");
        listEl.innerHTML = "";
        if (highscores.length === 0) {
          listEl.innerHTML = "<li>No high scores yet.</li>";
        } else {
          highscores.forEach((entry, index) => {
            const li = document.createElement("li");
            li.textContent = `${index + 1}. ${entry.name} - ${entry.score}`;
            listEl.appendChild(li);
          });
        }
        document.getElementById("highscoreOverlay").style.display = "flex";
      });
    }
    
    // Show stage complete overlay
    function showStageComplete() {
        // Log completion of current stage
        const completedStage = currentStage - 1;
        const currentStageData = timingData.stageData[completedStage];
        if (currentStageData) {
            currentStageData.endTime = Date.now();
            currentStageData.finalRemainingTime = remainingTime;
            currentStageData.completed = true;
            
            // Submit stage data to Firebase using the same gameId
            submitTimingData(`${currentGameId}_stage_${completedStage}`, {
                timestamp: Date.now(),
                stage: completedStage,
                stageData: currentStageData,
                patterns: currentStageData.patterns, // Use stage-specific patterns
                partialScore: score
            })
            .then(() => {
                console.log(`Stage ${completedStage} stats saved successfully`);
            })
            .catch((error) => {
                console.error(`Error saving stage ${completedStage} stats:`, error);
            });
        }
        
        // Initialize data for the new stage
        timingData.stageData[currentStage] = {
            attempts: 0,
            successes: 0,
            totalTime: 0,
            patterns: [],
            timeLimit: stageConfigs[currentStage].time,
            requiredPatterns: stageConfigs[currentStage].requiredPatterns,
            startTime: Date.now()
        };
        
        clearInterval(timerInterval);
        const overlay = document.createElement('div');
        overlay.className = 'stage-complete-overlay';
        
        const content = document.createElement('div');
        content.className = 'stage-complete-content';
        
        content.innerHTML = `
          <h2>Stage ${currentStage - 1} Complete!</h2>
          <p>Get ready for Stage ${currentStage}</p>
          <p>Time limit: ${stageConfigs[currentStage].time}s</p>
          <p>${currentStage > 5 ? "Complex patterns await..." : "New patterns await..."}</p>
          <div class="stage-countdown">3</div>
        `;
        
        overlay.appendChild(content);
        document.body.appendChild(overlay);
        
        // Generate the first pattern of the new stage before showing the overlay
        if (stagePatterns[currentStage]) {
            patterns = stagePatterns[currentStage];
        } else {
            console.error(`Missing patterns for stage ${currentStage}`);
            showGameComplete(); // End game if we don't have patterns for next stage
            return;
        }
        
        currentTarget = patterns[Math.floor(Math.random() * patterns.length)];
        updateTargetDisplay();
        
        // Countdown animation
        let count = 3;
        const countdownEl = content.querySelector('.stage-countdown');
        
        const countdownInterval = setInterval(() => {
          count--;
          if (count > 0) {
            countdownEl.textContent = count;
          } else {
            clearInterval(countdownInterval);
            document.body.removeChild(overlay);
            remainingTime = stageConfigs[currentStage].time;
            updateTimerDisplay();
            startTimer(true);
          }
        }, 1000);
    }

    // Show game complete overlay
    function showGameComplete() {
        // Submit complete game data to Firebase
        submitTimingData(currentGameId, {
            ...timingData,
            gameComplete: true,
            endReason: 'completed'
        })
        .then(() => {
            console.log('Complete game stats saved successfully');
        })
        .catch((error) => {
            console.error('Error saving complete game stats:', error);
        });
        
        // Get the high score before creating the overlay
        let highScore = localStorage.getItem("highScore") || 0;
        if (score > highScore) { 
            localStorage.setItem("highScore", score);
            highScore = score;
        }
        
        const overlay = document.createElement('div');
        overlay.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 40;
        `;
        const message = document.createElement('div');
        message.style.cssText = `
            background: #444;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        `;
        message.innerHTML = `
            <h2>Congratulations!</h2>
            <p>You've completed all stages!</p>
            <p>Final Score: ${score}</p>
            <p>High Score: ${highScore}</p>
            <input type="text" id="playerNameComplete" placeholder="Enter your name" style="
                margin: 10px 0;
                padding: 8px;
                width: 200px;
                border-radius: 5px;
                border: none;
            ">
            <button id="submitHighscoreBtnComplete" style="
                margin: 10px 5px;
                padding: 10px 20px;
                font-size: 16px;
                border: none;
                background: #FFD700;
                color: #222;
                cursor: pointer;
                border-radius: 5px;
            ">Submit Score</button>
            <button onclick="location.reload()" style="
                margin: 10px 5px;
                padding: 10px 20px;
                font-size: 16px;
                border: none;
                background: #FFD700;
                color: #222;
                cursor: pointer;
                border-radius: 5px;
            ">Play Again</button>
        `;
        overlay.appendChild(message);
        document.body.appendChild(overlay);

        // Add event listener for the submit button
        const submitBtn = message.querySelector('#submitHighscoreBtnComplete');
        submitBtn.addEventListener('click', () => {
            const playerName = message.querySelector('#playerNameComplete').value.trim();
            if (playerName === "") {
                alert("Please enter your name.");
                return;
            }
            submitHighScore(playerName, score)
                .then(() => {
                    submitBtn.disabled = true;
                    submitBtn.textContent = "Score Submitted!";
                    openHighscoreOverlay();
                })
                .catch((error) => {
                    console.error("Error submitting highscore:", error);
                    alert("Error submitting score. Please try again.");
                });
        });
    }

    // Menu background animation
    const menuPatterns = [
      [1, 5, 9],
      [3, 6, 9, 5, 1],
      [2, 4, 8, 6],
      [1, 8, 3, 4]
    ];
    let currentMenuPattern = 0;
    let menuAnimationInterval = null;
    let menuDrawnPattern = [];
    
    // Initialize menu background
    const menuCanvas = document.getElementById("menuLineCanvas");
    const menuCtx = menuCanvas.getContext("2d");
    
    function resizeMenuCanvas() {
      const menuBackground = document.getElementById("menuBackground");
      menuCanvas.width = menuBackground.offsetWidth;
      menuCanvas.height = menuBackground.offsetHeight;
      drawMenuLines(); // Redraw lines after resize
    }
    window.addEventListener("resize", resizeMenuCanvas);
    
    // Ensure canvas is properly sized on load
    window.addEventListener("load", resizeMenuCanvas);
    
    function clearMenuCanvas() {
      menuCtx.clearRect(0, 0, menuCanvas.width, menuCanvas.height);
    }
    
    function getMenuCircleCenter(index) {
      const circle = document.querySelector(`#menuBackgroundGrid .circle[data-index="${index}"]`);
      const rect = circle.getBoundingClientRect();
      const canvasRect = menuCanvas.getBoundingClientRect();
      return {
        x: rect.left + rect.width / 2 - canvasRect.left,
        y: rect.top + rect.height / 2 - canvasRect.top
      };
    }
    
    function drawMenuLines() {
      clearMenuCanvas();
      if (menuDrawnPattern.length === 0) return;
      
      menuCtx.lineWidth = 5;
      menuCtx.strokeStyle = "rgba(255, 215, 0, 0.5)";
      menuCtx.beginPath();
      
      for (let i = 0; i < menuDrawnPattern.length; i++) {
        const center = getMenuCircleCenter(menuDrawnPattern[i]);
        if (i === 0) {
          menuCtx.moveTo(center.x, center.y);
        } else {
          menuCtx.lineTo(center.x, center.y);
        }
      }
      menuCtx.stroke();
    }

    function resetMenuPattern() {
      menuDrawnPattern = [];
      document.querySelectorAll('#menuBackgroundGrid .circle').forEach(circle => {
        circle.classList.remove('active');
      });
      clearMenuCanvas();
    }
    
    function animateMenuPattern() {
      const pattern = menuPatterns[currentMenuPattern];
      let step = 0;
      
      function drawNextPoint() {
        if (step < pattern.length) {
          const index = pattern[step];
          menuDrawnPattern.push(index);
          const circle = document.querySelector(`#menuBackgroundGrid .circle[data-index="${index}"]`);
          circle.classList.add('active');
          drawMenuLines();
          step++;
          setTimeout(drawNextPoint, 300);
        } else {
          setTimeout(() => {
            resetMenuPattern();
            currentMenuPattern = (currentMenuPattern + 1) % menuPatterns.length;
            setTimeout(() => {
              animateMenuPattern();
            }, 700);
          }, 1000);
        }
      }
      
      drawNextPoint();
    }

    function startMenuAnimation() {
      resetMenuPattern();
      animateMenuPattern();
    }

    function stopMenuAnimation() {
      resetMenuPattern();
      if (menuAnimationInterval) {
        clearInterval(menuAnimationInterval);
        menuAnimationInterval = null;
      }
    }

    // Menu navigation
    document.getElementById("mainMenuBtn").addEventListener("click", () => {
      // Stop the game
      clearInterval(timerInterval);
      // Hide pause overlay
      document.getElementById("pauseOverlay").style.display = "none";
      // Reset game state
      score = 0;
      currentStage = 1;
      progress = 0;
      streak = 0;
      multiplier = 1;
      patterns = stagePatterns[1];
      remainingTime = 20; // Default time
      // Update UI
      updateUI();
      updateProgress();
      updateMultiplierBar('x1');
      document.getElementById('stageIndicator').textContent = 'Stage 1';
      // Show main menu and start animation
      document.getElementById("mainMenu").style.display = "flex";
      startMenuAnimation();
    });
    
    // Start menu animation when page loads
    startMenuAnimation();
    
    // Update settings close button to return to main menu
    document.getElementById("closeSettings").addEventListener("click", () => {
      document.getElementById("settings").style.display = "none";
    });
  </script>
</body>
</html>
